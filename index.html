<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Notes with Cloud Storage</title>
    <link rel="icon" type="image/png" href="logo.png">
    <!-- Supabase JavaScript SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-color: #ffffff;
            --surface-color: #f8f9fa;
            --border-color: #e9ecef;
            --text-color: #212529;
            --text-secondary: #6c757d;
            --primary-color: #0d6efd;
            --danger-color: #dc3545;
            --success-color: #198754;
            --warning-color: #ffc107;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --border-color: #333;
            --text-color: #ffffff;
            --text-secondary: #b3b3b3;
            --primary-color: #4285f4;
            --danger-color: #f28b82;
            --success-color: #81c995;
            --warning-color: #fdd663;
            --shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .header h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            font-weight: 700;
        }

        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .theme-toggle {
            background: none;
            border: 2px solid var(--border-color);
            color: var(--text-color);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .theme-toggle:hover {
            background-color: var(--surface-color);
            border-color: var(--primary-color);
        }

        .cloud-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            border-radius: 10px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            font-size: 14px;
            font-weight: 500;
        }

        .cloud-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success-color);
            animation: pulse 2s infinite;
        }

        .cloud-indicator.disconnected {
            background: var(--danger-color);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 40px;
            align-items: start;
        }

        .audio-section {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
        }

        .logo-icon {
            height: 1em;
            width: auto;
            vertical-align: middle;
        }

        .file-controls {
            margin-bottom: 25px;
        }

        .file-input-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input {
            position: absolute;
            left: -9999px;
            opacity: 0;
        }

        .file-input-label {
            background: var(--primary-color);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            display: inline-block;
        }

        .file-input-label:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .file-input-label.cloud {
            background: var(--success-color);
        }

        .current-folder,
        .current-file {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .folder-structure {
            margin-bottom: 20px;
        }

        .folder-section {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .folder-header {
            background: var(--surface-color);
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
        }

        .folder-header:hover {
            background: var(--border-color);
        }

        .folder-toggle {
            transition: transform 0.3s ease;
        }

        .folder-section.collapsed .folder-toggle {
            transform: rotate(-90deg);
        }

        .folder-files {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 15px;
        }

        .folder-section.collapsed .folder-files {
            display: none;
        }

        .folder-move-controls {
            display: flex;
            gap: 5px;
            margin-left: auto;
        }

        .btn-move {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .btn-move:hover {
            opacity: 0.8;
        }

        .file-tab {
            background: var(--border-color);
            color: var(--text-color);
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 500;
            position: relative;
        }

        .file-tab.active {
            background: var(--primary-color);
            color: white;
        }

        .file-tab:hover:not(.active) {
            background: var(--primary-color);
            color: white;
            opacity: 0.7;
        }

        .file-tab.cloud-file::after {
            content: '☁️';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 10px;
        }

        .audio-player {
            width: 100%;
            margin-bottom: 25px;
            height: 40px;
            border-radius: 8px;
        }

        .audio-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .time-display {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            padding: 8px 15px;
            border-radius: 6px;
            font-family: monospace;
            min-width: 120px;
            text-align: center;
        }

        .note-input-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .note-input {
            width: 100%;
            padding: 18px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 15px;
            line-height: 1.6;
            resize: vertical;
            min-height: 100px;
            transition: border-color 0.3s ease;
        }

        .note-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .note-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn-secondary {
            background: var(--text-secondary);
            color: white;
        }

        .btn:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .notes-sidebar {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            max-height: 80vh;
            overflow-y: auto;
        }

        .notes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .notes-header h3 {
            margin: 0;
            color: var(--text-color);
            font-size: 1.25rem;
            font-weight: 700;
        }

        .export-import-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .notes-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .note-item {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .note-item:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .note-timestamp {
            font-weight: 700;
            font-size: 15px;
            color: var(--primary-color);
            padding: 4px 8px;
            background: rgba(13, 110, 253, 0.1);
            border-radius: 6px;
            display: inline-block;
            margin-bottom: 10px;
        }

        .note-timestamp:hover {
            text-decoration: underline;
        }

        .note-text {
            color: var(--text-color);
            line-height: 1.4;
            margin-bottom: 10px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .note-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .btn-icon {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn-icon:hover {
            background: var(--surface-color);
        }

        .edit-mode .note-text {
            display: none;
        }

        .edit-mode .note-edit-input {
            display: block;
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-color);
            color: var(--text-color);
            margin-bottom: 10px;
            resize: vertical;
        }

        .note-edit-input {
            display: none;
        }

        .empty-state {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 40px 20px;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-playing {
            background: var(--success-color);
        }

        .status-paused {
            background: var(--warning-color);
        }

        .status-stopped {
            background: var(--text-secondary);
        }

        /* Enhanced Export/Import Styles */
        .data-management-section {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            margin-bottom: 30px;
        }

        .data-management-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .data-management-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 500;
            color: var(--text-color);
            font-size: 14px;
        }

        .dropdown-select {
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .dropdown-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status-message {
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }

        .status-success {
            background: rgba(25, 135, 84, 0.1);
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }

        .status-error {
            background: rgba(220, 53, 69, 0.1);
            color: var(--danger-color);
            border: 1px solid var(--danger-color);
        }

        .status-info {
            background: rgba(13, 110, 253, 0.1);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        /* Cloud Storage Styles */
        .cloud-section {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            margin-bottom: 30px;
        }

        .cloud-files-container {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .cloud-folder-tree {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .cloud-files-list {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .cloud-folder-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            margin-bottom: 4px;
            transition: background-color 0.3s ease;
        }

        .cloud-folder-item:hover {
            background: var(--surface-color);
        }

        .cloud-folder-item.active {
            background: var(--primary-color);
            color: white;
        }

        .cloud-folder-icon {
            margin-right: 8px;
            font-size: 14px;
        }

        .cloud-folder-name {
            font-size: 14px;
            font-weight: 500;
        }

        .cloud-file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.3s ease;
        }

        .cloud-file-item:last-child {
            border-bottom: none;
        }

        .cloud-file-item:hover {
            background: var(--surface-color);
        }

        .cloud-file-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .cloud-file-name {
            font-weight: 500;
            color: var(--text-color);
        }

        .cloud-file-meta {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .cloud-file-actions {
            display: flex;
            gap: 8px;
        }

        .upload-progress {
            margin-top: 15px;
        }

        .upload-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .upload-info {
            flex: 1;
        }

        .upload-name {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .upload-status {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            padding: 8px 12px;
            background: var(--surface-color);
            border-radius: 6px;
            font-size: 14px;
        }

        .breadcrumb-item {
            cursor: pointer;
            color: var(--primary-color);
            text-decoration: none;
        }

        .breadcrumb-item:hover {
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: var(--text-secondary);
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .header {
                text-align: center;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .header-controls {
                flex-direction: column;
                gap: 10px;
            }

            .file-input-group {
                justify-content: center;
            }

            .audio-controls {
                justify-content: center;
            }

            .note-controls {
                justify-content: center;
            }

            .export-import-controls {
                justify-content: center;
            }

            .data-management-controls {
                grid-template-columns: 1fr;
            }

            .cloud-files-container {
                grid-template-columns: 1fr;
            }
        }

        .cloud-section,
        .data-management-section {
            transition: all 0.3s ease;
            overflow: hidden;
            max-height: 1000px;
            opacity: 1;
            margin-bottom: 30px;
        }

        .cloud-section.hidden,
        .data-management-section.hidden {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
            border: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <header class="header">
            <h1>
                <img src="logo.png" alt="Logo" class="logo-icon"> Audio Notes
            </h1>
            <div class="header-controls">
                <button class="btn btn-secondary btn-small" onclick="toggleManagementPanels()" id="togglePanelsBtn">
                    ⚙️ Show Management
                </button>
                <div class="cloud-status" id="cloudStatus">
                    <div class="cloud-indicator disconnected" id="cloudIndicator"></div>
                    <span id="cloudStatusText">Connecting...</span>
                </div>
                <button class="theme-toggle" onclick="toggleTheme()">🌙 Dark Mode</button>
            </div>
        </header>

        <!-- Cloud Storage Section -->
        <section class="cloud-section">
            <div class="data-management-header">
                <h3>☁️ Cloud Storage</h3>
            </div>
            <div class="data-management-controls">
                <div class="control-group">
                    <label>Upload Audio Files</label>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <div class="file-input-wrapper">
                            <input type="file" id="cloudAudioFile" class="file-input" accept="audio/*" multiple>
                            <label for="cloudAudioFile" class="file-input-label cloud">☁️ Upload Files</label>
                        </div>
                        <div class="file-input-wrapper">
                            <input type="file" id="cloudFolderInput" class="file-input" webkitdirectory multiple>
                            <label for="cloudFolderInput" class="file-input-label cloud">📁 Upload Folder</label>
                        </div>
                        <button class="btn btn-secondary btn-small" onclick="refreshCloudFiles()">🔄 Refresh</button>
                    </div>
                </div>
            </div>

            <div class="cloud-files-container">
                <div class="cloud-folder-tree">
                    <h4 style="margin-bottom: 15px; color: var(--text-color);">📁 Folders</h4>
                    <div id="cloudFolderTree">
                        <div class="empty-state">No folders found</div>
                    </div>
                </div>

                <div>
                    <div class="breadcrumb" id="cloudBreadcrumb" style="display: none;">
                        <span class="breadcrumb-item" onclick="navigateToCloudFolder('')">🏠 Root</span>
                    </div>
                    <div class="cloud-files-list" id="cloudFilesList">
                        <div class="empty-state">No cloud files found</div>
                    </div>
                </div>
            </div>

            <div id="uploadProgress" class="upload-progress" style="display: none;"></div>
            <div id="cloudStatusMessage" style="display: none;"></div>
        </section>

        <!-- Enhanced Data Management Section -->
        <section class="data-management-section">
            <div class="data-management-header">
                <h3>📊 Data Management</h3>
            </div>
            <div class="data-management-controls">
                <div class="control-group">
                    <label for="exportFormat">Export Format</label>
                    <select id="exportFormat" class="dropdown-select">
                        <option value="json">JSON (Complete Data)</option>
                        <option value="csv">CSV (Notes Only)</option>
                        <option value="txt">Text (Notes Only)</option>
                        <option value="markdown">Markdown (Formatted)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="exportScope">Export Scope</label>
                    <select id="exportScope" class="dropdown-select">
                        <option value="current">Current File Only</option>
                        <option value="all">All Audio Files</option>
                        <option value="selected">Selected Files</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Actions</label>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="btn btn-success btn-small" onclick="exportAllData()">📤 Export Data</button>
                        <div class="file-input-wrapper">
                            <input type="file" id="importAllDataFile" class="file-input" accept=".json,.csv,.txt,.md">
                            <label for="importAllDataFile" class="btn btn-secondary btn-small">📥 Import Data</label>
                        </div>
                        <button class="btn btn-danger btn-small" onclick="clearAllData()">🗑️ Clear All</button>
                    </div>
                </div>
            </div>
            <div id="dataManagementStatus" style="display: none;"></div>
            <div id="dataManagementProgress" class="progress-bar" style="display: none;">
                <div class="progress-fill"></div>
            </div>
        </section>

        <main class="main-content">
            <section class="audio-section">
                <div class="file-controls">
                    <div class="file-input-group">
                        <div class="file-input-wrapper">
                            <input type="file" id="audioFile" class="file-input" accept="audio/*">
                            <label for="audioFile" class="file-input-label">📁 Select Audio File</label>
                        </div>
                        <div class="file-input-wrapper">
                            <input type="file" id="folderInput" class="file-input" webkitdirectory multiple>
                            <label for="folderInput" class="file-input-label">📂 Select Folder</label>
                        </div>
                    </div>

                    <div class="current-folder" id="currentFolder" style="display: none;">
                        Current Folder: <span id="folderName">None</span>
                    </div>

                    <div class="current-file" id="currentFile" style="display: none;">
                        Current File: <span id="fileName">None</span>
                    </div>

                    <div class="folder-structure" id="folderStructure"></div>
                </div>

                <audio id="audioPlayer" class="audio-player" controls style="display: none;">
                    Your browser does not support the audio element.
                </audio>

                <div class="audio-controls">
                    <div class="time-display" id="timeDisplay">
                        <span class="status-indicator status-stopped" id="statusIndicator"></span>
                        00:00 / 00:00
                    </div>
                </div>

                <div class="note-input-section">
                    <textarea id="noteInput" class="note-input"
                        placeholder="Write your note here..."
                        disabled></textarea>
                    <div class="note-controls">
                        <button id="addNoteBtn" class="btn btn-primary" onclick="addNote()" disabled>
                            📝 Add Note at Current Time
                        </button>
                    </div>
                </div>
            </section>

            <aside class="notes-sidebar">
                <div class="notes-header">
                    <h3>📋 Notes</h3>
                    <div class="export-import-controls">
                        <button class="btn btn-success btn-small" onclick="exportNotes()">📤 Export</button>
                        <div class="file-input-wrapper">
                            <input type="file" id="importFile" class="file-input" accept=".json">
                            <label for="importFile" class="btn btn-secondary btn-small">📥 Import</label>
                        </div>
                    </div>
                </div>

                <div id="notesList" class="notes-list">
                    <div class="empty-state">
                        Load an audio file to start taking notes
                    </div>
                </div>
            </aside>
        </main>
    </div>

    <script>
        // Supabase configuration
        const SUPABASE_URL = 'https://umwtaqtijwjfdugtefql.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVtd3RhcXRpandqZmR1Z3RlZnFsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkxODAxMDYsImV4cCI6MjA3NDc1NjEwNn0.w3zBFwypwk8rOZhtOkdFC1DH7S9qOaD98q1QnsQdTIo';

        // Initialize Supabase client
        let supabase;
        let cloudFiles = [];
        let cloudFolders = new Set();
        let currentCloudFolder = '';

        // Global variables
        let currentAudio = null;
        let notes = [];
        let currentFileName = '';
        let folderStructure = {};
        let currentFolderName = '';
        let allFiles = [];
        let folderOrder = [];
        let isCloudConnected = false;

        // Initialize app
        document.addEventListener('DOMContentLoaded', function () {
            loadTheme();
            setupEventListeners();
            initializeSupabase();
        });

        async function initializeSupabase() {
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

                // Test connection
                const { data, error } = await supabase.storage.listBuckets();

                if (error) {
                    throw error;
                }

                isCloudConnected = true;
                updateCloudStatus('connected', 'Cloud Connected');
                await refreshCloudFiles();

            } catch (error) {
                console.error('Supabase initialization error:', error);
                isCloudConnected = false;
                updateCloudStatus('disconnected', 'Cloud Disconnected');
            }
        }

        function updateCloudStatus(status, text) {
            const indicator = document.getElementById('cloudIndicator');
            const statusText = document.getElementById('cloudStatusText');

            indicator.className = `cloud-indicator ${status === 'connected' ? '' : 'disconnected'}`;
            statusText.textContent = text;
        }

        async function refreshCloudFiles() {
            let isRefreshing = false;
            if (isRefreshing || !isCloudConnected) {
                if (isRefreshing) {
                    showCloudStatus('info', 'Already refreshing...');
                }
                return;
            }

            isRefreshing = true;

            if (!isCloudConnected) {
                showCloudStatus('error', 'Not connected to cloud storage');
                return;
            }

            try {
                showCloudStatus('info', 'Loading cloud files...');

                // List all files in the audio-files bucket recursively
                const { data, error } = await supabase.storage
                    .from('audio-files')
                    .list('', {
                        limit: 1000,
                        offset: 0,
                        sortBy: { column: 'name', order: 'asc' }
                    });

                if (error) {
                    throw error;
                }

                // Process files and build folder structure
                cloudFiles = [];
                cloudFolders.clear();

                await processCloudFiles(data, '');

                renderCloudFolderTree();
                renderCloudFiles();
                showCloudStatus('success', `Found ${cloudFiles.length} cloud files in ${cloudFolders.size} folders`);

                setTimeout(() => hideCloudStatus(), 3000);

            } catch (error) {
                console.error('Error loading cloud files:', error);
                showCloudStatus('error', 'Failed to load cloud files: ' + error.message);
                cloudFiles = [];
                cloudFolders.clear();
                renderCloudFolderTree();
                renderCloudFiles();
            } finally {
                isRefreshing = false;
            }
        }

        async function processCloudFiles(items, currentPath) {
            for (const item of items) {
                const fullPath = currentPath ? `${currentPath}/${item.name}` : item.name;

                if (item.metadata && item.metadata.mimetype) {
                    // It's a file
                    if (item.metadata.mimetype.startsWith('audio/')) {
                        cloudFiles.push({
                            ...item,
                            fullPath: fullPath,
                            folder: currentPath
                        });
                    }
                } else {
                    // It's a folder, add to folders set and recursively list contents
                    if (item.name && !item.name.includes('.')) {
                        cloudFolders.add(fullPath);

                        try {
                            const { data: subItems, error } = await supabase.storage
                                .from('audio-files')
                                .list(fullPath, {
                                    limit: 1000,
                                    offset: 0,
                                    sortBy: { column: 'name', order: 'asc' }
                                });

                            if (!error && subItems) {
                                await processCloudFiles(subItems, fullPath);
                            }
                        } catch (subError) {
                            console.warn(`Error listing folder ${fullPath}:`, subError);
                        }
                    }
                }
            }
        }

        function renderCloudFolderTree() {
            const folderTree = document.getElementById('cloudFolderTree');

            if (cloudFolders.size === 0) {
                folderTree.innerHTML = '<div class="empty-state">No folders found</div>';
                return;
            }

            const sortedFolders = Array.from(cloudFolders).sort();

            folderTree.innerHTML = `
                <div class="cloud-folder-item ${currentCloudFolder === '' ? 'active' : ''}" onclick="navigateToCloudFolder('')">
                    <span class="cloud-folder-icon">🏠</span>
                    <span class="cloud-folder-name">Root</span>
                </div>
                ${sortedFolders.map(folder => `
                    <div class="cloud-folder-item ${currentCloudFolder === folder ? 'active' : ''}" onclick="navigateToCloudFolder('${escapeHtml(folder).replace(/'/g, '\\\'')}')" title="${escapeHtml(folder)}">
                        <span class="cloud-folder-icon">📁</span>
                        <span class="cloud-folder-name">${escapeHtml(folder.split('/').pop())}</span>
                    </div>
                `).join('')}
            `;
        }

        function navigateToCloudFolder(folderPath) {
            currentCloudFolder = folderPath;
            renderCloudFolderTree();
            renderCloudFiles();
            updateCloudBreadcrumb();
        }

        function updateCloudBreadcrumb() {
            const breadcrumb = document.getElementById('cloudBreadcrumb');

            if (!currentCloudFolder) {
                breadcrumb.style.display = 'none';
                return;
            }

            breadcrumb.style.display = 'flex';
            const pathParts = currentCloudFolder.split('/');
            let breadcrumbHTML = '<span class="breadcrumb-item" onclick="navigateToCloudFolder(\'\')">🏠 Root</span>';

            let currentPath = '';
            pathParts.forEach((part, index) => {
                currentPath += (currentPath ? '/' : '') + part;
                breadcrumbHTML += `
                    <span class="breadcrumb-separator">›</span>
                    <span class="breadcrumb-item" onclick="navigateToCloudFolder('${escapeHtml(currentPath).replace(/'/g, '\\\'')}')">${escapeHtml(part)}</span>
                `;
            });

            breadcrumb.innerHTML = breadcrumbHTML;
        }

        function renderCloudFiles() {
            const cloudFilesList = document.getElementById('cloudFilesList');

            // Filter files by current folder
            const filteredFiles = cloudFiles.filter(file => file.folder === currentCloudFolder);

            if (filteredFiles.length === 0) {
                cloudFilesList.innerHTML = '<div class="empty-state">No files in this folder</div>';
                return;
            }

            cloudFilesList.innerHTML = filteredFiles.map(file => `
                <div class="cloud-file-item">
                    <div class="cloud-file-info">
                        <div class="cloud-file-name">${escapeHtml(file.name)}</div>
                        <div class="cloud-file-meta">
                            ${formatFileSize(file.metadata?.size || 0)} • 
                            ${new Date(file.updated_at || file.created_at).toLocaleDateString()}
                        </div>
                    </div>
                    <div class="cloud-file-actions">
                        <button class="btn-icon" onclick="loadCloudFile('${escapeHtml(file.fullPath).replace(/'/g, '\\\'')}')" title="Load">▶️</button>
                        <button class="btn-icon" onclick="downloadCloudFile('${escapeHtml(file.fullPath).replace(/'/g, '\\\'')}')" title="Download">⬇️</button>
                        <button class="btn-icon" onclick="deleteCloudFile('${escapeHtml(file.fullPath).replace(/'/g, '\\\'')}')" title="Delete">🗑️</button>
                    </div>
                </div>
            `).join('');
        }

        async function loadCloudFile(filePath) {
            if (!isCloudConnected) {
                alert('Not connected to cloud storage');
                return;
            }

            try {
                showCloudStatus('info', 'Loading cloud file...');

                const { data, error } = await supabase.storage
                    .from('audio-files')
                    .download(filePath);

                if (error) {
                    throw error;
                }

                // Create a File object from the blob
                const fileName = filePath.split('/').pop();
                const file = new File([data], fileName, { type: data.type });

                // Load the file as if it was selected locally
                allFiles = [file];
                folderOrder = [];
                folderStructure = {};
                currentFolderName = '';

                loadAudioFile(file);
                updateFolderDisplay();

                showCloudStatus('success', 'Cloud file loaded successfully');
                setTimeout(() => hideCloudStatus(), 3000);

            } catch (error) {
                console.error('Error loading cloud file:', error);
                showCloudStatus('error', 'Failed to load cloud file: ' + error.message);
            }
        }

        async function downloadCloudFile(filePath) {
            if (!isCloudConnected) {
                alert('Not connected to cloud storage');
                return;
            }

            try {
                showCloudStatus('info', 'Downloading file...');

                const { data, error } = await supabase.storage
                    .from('audio-files')
                    .download(filePath);

                if (error) {
                    throw error;
                }

                // Create download link
                const url = URL.createObjectURL(data);
                const a = document.createElement('a');
                a.href = url;
                a.download = filePath.split('/').pop();
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showCloudStatus('success', 'File downloaded successfully');
                setTimeout(() => hideCloudStatus(), 3000);

            } catch (error) {
                console.error('Error downloading cloud file:', error);
                showCloudStatus('error', 'Failed to download file: ' + error.message);
            }
        }

        async function deleteCloudFile(filePath) {
            if (!isCloudConnected) {
                alert('Not connected to cloud storage');
                return;
            }

            if (!confirm(`Are you sure you want to delete "${filePath}" from cloud storage?`)) {
                return;
            }

            try {
                showCloudStatus('info', 'Deleting file...');

                const { error } = await supabase.storage
                    .from('audio-files')
                    .remove([filePath]);

                if (error) {
                    throw error;
                }

                await refreshCloudFiles();
                showCloudStatus('success', 'File deleted successfully');
                setTimeout(() => hideCloudStatus(), 3000);

            } catch (error) {
                console.error('Error deleting cloud file:', error);
                showCloudStatus('error', 'Failed to delete file: ' + error.message);
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function showCloudStatus(type, message) {
            const statusDiv = document.getElementById('cloudStatusMessage');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        function hideCloudStatus() {
            const statusDiv = document.getElementById('cloudStatusMessage');
            statusDiv.style.display = 'none';
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function getFileIndex(file) {
            return allFiles.findIndex(f => f.name === file.name && f.size === file.size);
        }

        function selectFile(index, folderPath) {
            if (index >= 0 && index < allFiles.length) {
                if (folderPath) {
                    moveToTop(folderPath);
                }
                loadAudioFile(allFiles[index]);

                setTimeout(() => {
                    if (folderPath) {
                        const folderId = `folder-${folderPath.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        const folderElement = document.getElementById(folderId);
                        if (folderElement) {
                            const folderSection = folderElement.parentElement;
                            folderSection.classList.remove('collapsed');
                        }
                    }
                }, 100);
            }
        }

        function moveToTop(folderPath) {
            if (!folderPath) return;

            const currentIndex = folderOrder.indexOf(folderPath);
            if (currentIndex > -1) {
                folderOrder.splice(currentIndex, 1);
            }

            folderOrder.unshift(folderPath);
            updateFolderDisplay();
        }

        function setupEventListeners() {
            const audioFile = document.getElementById('audioFile');
            const folderInput = document.getElementById('folderInput');
            const audioPlayer = document.getElementById('audioPlayer');
            const importFile = document.getElementById('importFile');
            const importAllDataFile = document.getElementById('importAllDataFile');
            const cloudAudioFile = document.getElementById('cloudAudioFile');
            const cloudFolderInput = document.getElementById('cloudFolderInput');

            audioFile.addEventListener('change', handleSingleFileSelect);
            folderInput.addEventListener('change', handleFolderSelect);
            importFile.addEventListener('change', handleImportFile);
            importAllDataFile.addEventListener('change', handleImportAllData);
            cloudAudioFile.addEventListener('change', handleCloudUpload);
            cloudFolderInput.addEventListener('change', handleCloudFolderUpload);

            audioPlayer.addEventListener('timeupdate', updateTimeDisplay);
            audioPlayer.addEventListener('play', updateStatus);
            audioPlayer.addEventListener('pause', updateStatus);
            audioPlayer.addEventListener('ended', updateStatus);
            audioPlayer.addEventListener('loadstart', updateStatus);
            audioPlayer.addEventListener('loadedmetadata', updateTimeDisplay);
            audioPlayer.addEventListener('durationchange', updateTimeDisplay);
        }

        async function handleCloudUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            if (!isCloudConnected) {
                alert('Not connected to cloud storage');
                event.target.value = '';
                return;
            }

            const uploadProgressDiv = document.getElementById('uploadProgress');
            uploadProgressDiv.style.display = 'block';
            uploadProgressDiv.innerHTML = '';

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                await uploadFileToCloud(file, i + 1, files.length, '');
            }

            event.target.value = '';
            await refreshCloudFiles();
        }

        async function handleCloudFolderUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            if (!isCloudConnected) {
                alert('Not connected to cloud storage');
                event.target.value = '';
                return;
            }

            // Filter audio files
            const audioFiles = files.filter(file => file.type.startsWith('audio/'));

            if (audioFiles.length === 0) {
                alert('No audio files found in the selected folder.');
                event.target.value = '';
                return;
            }

            const uploadProgressDiv = document.getElementById('uploadProgress');
            uploadProgressDiv.style.display = 'block';
            uploadProgressDiv.innerHTML = '';

            for (let i = 0; i < audioFiles.length; i++) {
                const file = audioFiles[i];
                // Preserve folder structure using webkitRelativePath
                const relativePath = file.webkitRelativePath || file.name;
                await uploadFileToCloud(file, i + 1, audioFiles.length, relativePath);
            }

            event.target.value = '';
            await refreshCloudFiles();
        }

        async function uploadFileToCloud(file, index, total, relativePath) {
            const uploadProgressDiv = document.getElementById('uploadProgress');

            const uploadItem = document.createElement('div');
            uploadItem.className = 'upload-item';
            uploadItem.innerHTML = `
                <div class="upload-info">
                    <div class="upload-name">${escapeHtml(relativePath || file.name)}</div>
                    <div class="upload-status">Uploading... (${index}/${total})</div>
                </div>
                <div class="progress-bar" style="width: 200px;">
                    <div class="progress-fill" style="width: 0%;"></div>
                </div>
            `;
            uploadProgressDiv.appendChild(uploadItem);

            const progressFill = uploadItem.querySelector('.progress-fill');
            const statusDiv = uploadItem.querySelector('.upload-status');

            try {
                // Use relative path if provided (for folder uploads), otherwise generate unique filename

                // Use the relative path directly to preserve folder structure
                // Supabase handles encoding internally, so we don't need to encode
                const fileName = relativePath || file.name;

                progressFill.style.width = '10%';
                statusDiv.textContent = 'Preparing upload...';

                const { data, error } = await supabase.storage
                    .from('audio-files')
                    .upload(fileName, file, {
                        cacheControl: '3600',
                        upsert: false
                    });

                if (error) {
                    throw error;
                }

                progressFill.style.width = '100%';
                statusDiv.textContent = 'Upload completed!';
                uploadItem.style.borderColor = 'var(--success-color)';

            } catch (error) {
                console.error('Upload error:', error);
                progressFill.style.width = '100%';
                progressFill.style.background = 'var(--danger-color)';
                statusDiv.textContent = 'Upload failed: ' + error.message;
                uploadItem.style.borderColor = 'var(--danger-color)';
            }
        }

        function handleSingleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                allFiles = [file];
                folderOrder = [];
                folderStructure = {};
                currentFolderName = '';

                loadAudioFile(file);
                updateFolderDisplay();
            }
        }

        function handleFolderSelect(event) {
            const files = Array.from(event.target.files);
            const audioFiles = files.filter(file => file.type.startsWith('audio/'));

            if (audioFiles.length === 0) {
                alert('No audio files found in the selected folder.');
                return;
            }

            allFiles = audioFiles;
            folderStructure = buildFolderStructure(audioFiles);
            const rootFolders = Object.keys(folderStructure);
            currentFolderName = rootFolders.length > 0 ? rootFolders[0] : 'Selected Folder';

            updateFolderDisplay();

            const firstFile = getFirstAudioFile(folderStructure);
            if (firstFile) {
                loadAudioFile(firstFile);
            }
        }

        function buildFolderStructure(files) {
            const structure = {};
            folderOrder = [];

            files.forEach(file => {
                const pathParts = file.webkitRelativePath ? file.webkitRelativePath.split('/') : [file.name];

                if (pathParts.length === 1) {
                    const rootFolder = 'Root';
                    if (!structure[rootFolder]) {
                        structure[rootFolder] = { _files: [] };
                    }
                    structure[rootFolder]._files.push(file);

                    if (!folderOrder.includes('Root')) {
                        folderOrder.push('Root');
                    }
                    return;
                }

                const rootFolder = pathParts[0];
                if (!structure[rootFolder]) {
                    structure[rootFolder] = {};
                }

                let current = structure[rootFolder];
                let currentPath = rootFolder;

                for (let i = 1; i < pathParts.length - 1; i++) {
                    const folderName = pathParts[i];
                    currentPath += '/' + folderName;

                    if (!current[folderName]) {
                        current[folderName] = {};
                    }
                    current = current[folderName];
                }

                const fileName = pathParts[pathParts.length - 1];
                if (!current._files) {
                    current._files = [];
                }
                current._files.push(file);

                const fullPath = pathParts.slice(0, -1).join('/');
                if (!folderOrder.includes(fullPath)) {
                    folderOrder.push(fullPath);
                }
            });

            return structure;
        }

        function getFirstAudioFile(structure) {
            for (const key in structure) {
                if (key === '_files' && structure[key] && structure[key].length > 0) {
                    return structure[key][0];
                } else if (typeof structure[key] === 'object') {
                    const file = getFirstAudioFile(structure[key]);
                    if (file) return file;
                }
            }
            return null;
        }

        function updateFolderDisplay() {
            const folderDiv = document.getElementById('currentFolder');
            const folderName = document.getElementById('folderName');
            const folderStructureDiv = document.getElementById('folderStructure');

            if (Object.keys(folderStructure).length > 0) {
                folderDiv.style.display = 'block';
                folderName.textContent = currentFolderName;

                folderStructureDiv.innerHTML = '';
                renderFolderStructure(folderStructure, folderStructureDiv);
            } else {
                folderDiv.style.display = 'none';
                folderStructureDiv.innerHTML = '';
            }
        }

        function renderFolderStructure(structure, container, path = '') {
            const folderData = [];

            function collectFolders(struct, currentPath) {
                for (const key in struct) {
                    if (key === '_files') {
                        const files = struct[key];
                        if (files && files.length > 0) {
                            const displayPath = currentPath || 'Root';
                            const fullPath = currentPath;
                            folderData.push({
                                path: displayPath,
                                fullPath: fullPath,
                                files: files,
                                order: folderOrder.indexOf(fullPath)
                            });
                        }
                    } else {
                        const subPath = currentPath ? `${currentPath}/${key}` : key;
                        collectFolders(struct[key], subPath);
                    }
                }
            }

            collectFolders(structure, path);

            folderData.sort((a, b) => {
                const orderA = a.order === -1 ? Infinity : a.order;
                const orderB = b.order === -1 ? Infinity : b.order;
                return orderA - orderB;
            });

            folderData.forEach(folder => {
                const folderSection = document.createElement('div');
                folderSection.className = 'folder-section collapsed';

                const folderId = `folder-${folder.fullPath.replace(/[^a-zA-Z0-9]/g, '_')}`;

                const folderHeaderContent = `
                    <span>📁 ${escapeHtml(folder.path)}</span>
                    <div class="folder-move-controls">
                        ${folder.fullPath ? `<button class="btn-move" onclick="event.stopPropagation(); moveToTop('${escapeHtml(folder.fullPath).replace(/'/g, '\\\'')}')" title="Move to top">↑</button>` : ''}
                        <span class="folder-toggle">▼</span>
                    </div>
                `;

                const folderFilesContent = folder.files.map((file, index) => {
                    const fileIndex = getFileIndex(file);
                    const isCloudFile = file.name && file.name.includes('_') && !isNaN(file.name.split('_')[0]);
                    return `
                        <button class="file-tab ${file.name === currentFileName ? 'active' : ''} ${isCloudFile ? 'cloud-file' : ''}" 
                                onclick="selectFile(${fileIndex}, '${escapeHtml(folder.fullPath).replace(/'/g, '\\\'')}')"
                                title="${escapeHtml(file.name)}">
                            ${escapeHtml(file.name)}
                        </button>
                    `;
                }).join('');

                folderSection.innerHTML = `
                    <div class="folder-header" onclick="toggleFolder('${folderId}')">
                        ${folderHeaderContent}
                    </div>
                    <div class="folder-files" id="${folderId}">
                        ${folderFilesContent}
                    </div>
                `;

                container.appendChild(folderSection);
            });
        }

        function toggleFolder(folderId) {
            const folderElement = document.getElementById(folderId);
            if (folderElement) {
                const folderSection = folderElement.parentElement;
                folderSection.classList.toggle('collapsed');
            }
        }

        function loadAudioFile(file) {
            // Validate file type
            if (!file.type.startsWith('audio/')) {
                alert('Please select a valid audio file. Selected file type: ' + (file.type || 'unknown'));
                return;
            }

            // Hide cloud and data management sections
            document.querySelector('.cloud-section').classList.add('hidden');
            document.querySelector('.data-management-section').classList.add('hidden');

            currentFileName = file.name;

            const audioPlayer = document.getElementById('audioPlayer');
            const fileNameSpan = document.getElementById('fileName');
            const currentFileDiv = document.getElementById('currentFile');
            const noteInput = document.getElementById('noteInput');
            const addNoteBtn = document.getElementById('addNoteBtn');

            if (currentAudio) {
                URL.revokeObjectURL(currentAudio);
            }

            try {
                currentAudio = URL.createObjectURL(file);
                audioPlayer.src = currentAudio;
                audioPlayer.style.display = 'block';
                audioPlayer.currentTime = 0;

            } catch (error) {
                console.error('Error creating object URL:', error);
                alert('Error loading audio file. Please try again.');
                return;
            }

            currentFileDiv.style.display = 'block';
            fileNameSpan.textContent = currentFileName;

            noteInput.disabled = false;
            addNoteBtn.disabled = false;

            loadNotesForFile();
            updateFolderDisplay();
        }

        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return '00:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimeDisplay() {
            const audioPlayer = document.getElementById('audioPlayer');
            const timeDisplay = document.getElementById('timeDisplay');

            if (!audioPlayer || !timeDisplay) {
                return;
            }

            const current = formatTime(audioPlayer.currentTime || 0);
            const duration = formatTime(audioPlayer.duration || 0);
            const statusIndicator = document.getElementById('statusIndicator');

            timeDisplay.innerHTML = `<span class="status-indicator ${statusIndicator.className}" id="statusIndicator"></span>${current} / ${duration}`;
        }

        function updateStatus() {
            const audioPlayer = document.getElementById('audioPlayer');
            const statusIndicator = document.getElementById('statusIndicator');

            if (!audioPlayer || !statusIndicator) {
                return;
            }

            statusIndicator.className = 'status-indicator ';

            if (audioPlayer.paused) {
                if (audioPlayer.currentTime === 0) {
                    statusIndicator.className += 'status-stopped';
                } else {
                    statusIndicator.className += 'status-paused';
                }
            } else {
                statusIndicator.className += 'status-playing';
            }
        }

        function addNote() {
            const audioPlayer = document.getElementById('audioPlayer');
            const noteInput = document.getElementById('noteInput');

            if (!audioPlayer || !noteInput || !currentFileName) {
                return;
            }

            const text = noteInput.value.trim();
            if (!text) {
                alert('Please enter a note before adding.');
                return;
            }

            const timestamp = audioPlayer.currentTime || 0;
            const timeString = formatTime(timestamp);

            const note = {
                id: Date.now() + Math.random(),
                timestamp: timestamp,
                timeString: timeString,
                text: text,
                fileName: currentFileName,
                createdAt: new Date().toISOString()
            };

            notes.push(note);
            notes.sort((a, b) => a.timestamp - b.timestamp);

            noteInput.value = '';
            saveNotesForFile();
            renderNotes();
        }

        function deleteNote(id) {
            if (confirm('Are you sure you want to delete this note?')) {
                notes = notes.filter(note => note.id !== id);
                saveNotesForFile();
                renderNotes();
            }
        }

        function editNote(id) {
            const noteItem = document.querySelector(`[data-note-id="${id}"]`);
            if (noteItem) {
                noteItem.classList.add('edit-mode');

                const editBtn = noteItem.querySelector('button[onclick*="editNote"]');
                const saveBtn = noteItem.querySelector('button[onclick*="saveNote"]');
                const cancelBtn = noteItem.querySelector('button[onclick*="cancelEdit"]');

                if (editBtn) editBtn.style.display = 'none';
                if (saveBtn) saveBtn.style.display = 'inline-block';
                if (cancelBtn) cancelBtn.style.display = 'inline-block';
            }
        }

        function saveNote(id) {
            const noteItem = document.querySelector(`[data-note-id="${id}"]`);
            if (!noteItem) return;

            const editInput = noteItem.querySelector('.note-edit-input');
            if (!editInput) return;

            const newText = editInput.value.trim();

            if (!newText) {
                alert('Note cannot be empty.');
                return;
            }

            const note = notes.find(n => n.id === id);
            if (note) {
                note.text = newText;
                saveNotesForFile();
                renderNotes();
            }
        }

        function cancelEdit(id) {
            const noteItem = document.querySelector(`[data-note-id="${id}"]`);
            if (noteItem) {
                noteItem.classList.remove('edit-mode');

                const editBtn = noteItem.querySelector('button[onclick*="editNote"]');
                const saveBtn = noteItem.querySelector('button[onclick*="saveNote"]');
                const cancelBtn = noteItem.querySelector('button[onclick*="cancelEdit"]');

                if (editBtn) editBtn.style.display = 'inline-block';
                if (saveBtn) saveBtn.style.display = 'none';
                if (cancelBtn) cancelBtn.style.display = 'none';
            }
        }

        function jumpToTime(timestamp) {
            const audioPlayer = document.getElementById('audioPlayer');
            if (audioPlayer && !isNaN(timestamp) && timestamp >= 0) {
                audioPlayer.currentTime = timestamp;
                audioPlayer.focus();
            }
        }

        function renderNotes() {
            const notesList = document.getElementById('notesList');

            if (notes.length === 0) {
                notesList.innerHTML = '<div class="empty-state">No notes yet. Add a note using the form above.</div>';
                return;
            }

            notesList.innerHTML = notes.map(note => `
                <div class="note-item" data-note-id="${note.id}">
                    <div class="note-timestamp" onclick="jumpToTime(${note.timestamp})">
                        ${escapeHtml(note.timeString)}
                    </div>
                    <div class="note-text">${escapeHtml(note.text)}</div>
                    <textarea class="note-edit-input">${escapeHtml(note.text)}</textarea>
                    <div class="note-actions">
                        <button class="btn-icon" onclick="editNote(${note.id})" title="Edit">✏️</button>
                        <button class="btn-icon" onclick="saveNote(${note.id})" title="Save" style="display: none;">💾</button>
                        <button class="btn-icon" onclick="cancelEdit(${note.id})" title="Cancel" style="display: none;">❌</button>
                        <button class="btn-icon" onclick="deleteNote(${note.id})" title="Delete">🗑️</button>
                    </div>
                </div>
            `).join('');

            notes.forEach(note => {
                const noteItem = document.querySelector(`[data-note-id="${note.id}"]`);
                if (!noteItem) return;

                const editInput = noteItem.querySelector('.note-edit-input');
                if (!editInput) return;

                editInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        cancelEdit(note.id);
                    } else if (e.key === 'Enter' && e.ctrlKey) {
                        saveNote(note.id);
                    }
                });
            });
        }

        function getNotesKey() {
            return `notes_${currentFileName}`;
        }

        function saveNotesForFile() {
            if (currentFileName) {
                const key = getNotesKey();
                try {
                    localStorage.setItem(key, JSON.stringify(notes));
                } catch (error) {
                    console.error('Error saving notes to localStorage:', error);
                }
            }
        }

        function loadNotesForFile() {
            if (currentFileName) {
                const key = getNotesKey();
                try {
                    const savedNotes = localStorage.getItem(key);
                    notes = savedNotes ? JSON.parse(savedNotes) : [];
                } catch (error) {
                    console.error('Error loading notes from localStorage:', error);
                    notes = [];
                }
                renderNotes();
            }
        }

        function exportNotes() {
            if (notes.length === 0) {
                alert('No notes to export.');
                return;
            }

            const exportData = {
                fileName: currentFileName,
                exportDate: new Date().toISOString(),
                notes: notes
            };

            try {
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentFileName.replace(/\.[^/.]+$/, '')}_notes.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error exporting notes:', error);
                alert('Error exporting notes. Please try again.');
            }
        }

        function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const importData = JSON.parse(e.target.result);

                    if (importData.notes && Array.isArray(importData.notes)) {
                        const shouldReplace = confirm(
                            `Import ${importData.notes.length} notes? This will replace existing notes for the current file.`
                        );

                        if (shouldReplace) {
                            notes = importData.notes.map(note => ({
                                ...note,
                                id: note.id || Date.now() + Math.random(),
                                timeString: note.timeString || formatTime(note.timestamp || 0)
                            }));
                            notes.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
                            saveNotesForFile();
                            renderNotes();
                            alert('Notes imported successfully!');
                        }
                    } else {
                        alert('Invalid notes file format.');
                    }
                } catch (error) {
                    console.error('Error importing notes:', error);
                    alert('Error reading notes file: ' + error.message);
                }

                event.target.value = '';
            };

            reader.onerror = function (error) {
                console.error('FileReader error:', error);
                alert('Error reading file. Please try again.');
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // Enhanced Data Management Functions
        function getAllStoredData() {
            const allData = {};
            const keys = Object.keys(localStorage);

            keys.forEach(key => {
                if (key.startsWith('notes_')) {
                    const fileName = key.replace('notes_', '');
                    try {
                        const notes = JSON.parse(localStorage.getItem(key));
                        allData[fileName] = {
                            fileName: fileName,
                            notes: notes,
                            noteCount: notes.length,
                            lastModified: notes.length > 0 ? Math.max(...notes.map(n => new Date(n.createdAt || 0).getTime())) : 0
                        };
                    } catch (error) {
                        console.error(`Error parsing data for ${fileName}:`, error);
                    }
                }
            });

            return allData;
        }

        function exportAllData() {
            const format = document.getElementById('exportFormat').value;
            const scope = document.getElementById('exportScope').value;
            const statusDiv = document.getElementById('dataManagementStatus');
            const progressDiv = document.getElementById('dataManagementProgress');
            const progressFill = progressDiv.querySelector('.progress-fill');

            showStatus('info', 'Preparing export...');
            showProgress(0);

            setTimeout(() => {
                try {
                    let dataToExport = {};
                    const allData = getAllStoredData();

                    switch (scope) {
                        case 'current':
                            if (currentFileName && allData[currentFileName]) {
                                dataToExport[currentFileName] = allData[currentFileName];
                            } else {
                                showStatus('error', 'No current file selected or no data found.');
                                hideProgress();
                                return;
                            }
                            break;
                        case 'all':
                            dataToExport = allData;
                            break;
                        case 'selected':
                            // For now, export all - could be enhanced with file selection UI
                            dataToExport = allData;
                            break;
                    }

                    if (Object.keys(dataToExport).length === 0) {
                        showStatus('error', 'No data found to export.');
                        hideProgress();
                        return;
                    }

                    showProgress(50);

                    let exportContent, mimeType, fileExtension;

                    switch (format) {
                        case 'json':
                            exportContent = JSON.stringify({
                                exportDate: new Date().toISOString(),
                                exportFormat: 'json',
                                exportScope: scope,
                                totalFiles: Object.keys(dataToExport).length,
                                totalNotes: Object.values(dataToExport).reduce((sum, file) => sum + file.noteCount, 0),
                                data: dataToExport
                            }, null, 2);
                            mimeType = 'application/json';
                            fileExtension = 'json';
                            break;

                        case 'csv':
                            const csvRows = ['File Name,Timestamp,Time String,Note Text,Created At'];
                            Object.values(dataToExport).forEach(fileData => {
                                fileData.notes.forEach(note => {
                                    const row = [
                                        `"${fileData.fileName}"`,
                                        note.timestamp || 0,
                                        `"${note.timeString || ''}"`,
                                        `"${(note.text || '').replace(/"/g, '""')}"`,
                                        `"${note.createdAt || ''}"`
                                    ].join(',');
                                    csvRows.push(row);
                                });
                            });
                            exportContent = csvRows.join('\n');
                            mimeType = 'text/csv';
                            fileExtension = 'csv';
                            break;

                        case 'txt':
                            const txtLines = [`Audio Notes Export - ${new Date().toLocaleString()}`, ''];
                            Object.values(dataToExport).forEach(fileData => {
                                txtLines.push(`=== ${fileData.fileName} ===`);
                                txtLines.push(`Notes: ${fileData.noteCount}`);
                                txtLines.push('');
                                fileData.notes.forEach(note => {
                                    txtLines.push(`[${note.timeString}] ${note.text}`);
                                });
                                txtLines.push('');
                            });
                            exportContent = txtLines.join('\n');
                            mimeType = 'text/plain';
                            fileExtension = 'txt';
                            break;

                        case 'markdown':
                            const mdLines = [`# Audio Notes Export`, `*Generated on ${new Date().toLocaleString()}*`, ''];
                            Object.values(dataToExport).forEach(fileData => {
                                mdLines.push(`## ${fileData.fileName}`);
                                mdLines.push(`**Notes:** ${fileData.noteCount}`);
                                mdLines.push('');
                                fileData.notes.forEach(note => {
                                    mdLines.push(`### ${note.timeString}`);
                                    mdLines.push(note.text);
                                    mdLines.push('');
                                });
                            });
                            exportContent = mdLines.join('\n');
                            mimeType = 'text/markdown';
                            fileExtension = 'md';
                            break;
                    }

                    showProgress(90);

                    const blob = new Blob([exportContent], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `audio_notes_export_${new Date().toISOString().split('T')[0]}.${fileExtension}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    showProgress(100);
                    showStatus('success', `Export completed! ${Object.keys(dataToExport).length} files exported.`);

                    setTimeout(() => {
                        hideProgress();
                        hideStatus();
                    }, 3000);

                } catch (error) {
                    console.error('Export error:', error);
                    showStatus('error', 'Export failed: ' + error.message);
                    hideProgress();
                }
            }, 500);
        }

        function handleImportAllData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const statusDiv = document.getElementById('dataManagementStatus');
            const progressDiv = document.getElementById('dataManagementProgress');

            showStatus('info', 'Reading import file...');
            showProgress(0);

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    showProgress(30);

                    let importData;
                    const fileExtension = file.name.split('.').pop().toLowerCase();

                    if (fileExtension === 'json') {
                        importData = JSON.parse(e.target.result);

                        if (importData.data && typeof importData.data === 'object') {
                            // New format with metadata
                            const filesToImport = Object.keys(importData.data);
                            const totalNotes = Object.values(importData.data).reduce((sum, file) => sum + (file.notes ? file.notes.length : 0), 0);

                            const shouldImport = confirm(
                                `Import data for ${filesToImport.length} audio files (${totalNotes} total notes)?\n\nThis will replace existing data for these files.`
                            );

                            if (shouldImport) {
                                showProgress(60);

                                let importedFiles = 0;
                                let importedNotes = 0;

                                Object.entries(importData.data).forEach(([fileName, fileData]) => {
                                    if (fileData.notes && Array.isArray(fileData.notes)) {
                                        const key = `notes_${fileName}`;
                                        const processedNotes = fileData.notes.map(note => ({
                                            ...note,
                                            id: note.id || Date.now() + Math.random(),
                                            timeString: note.timeString || formatTime(note.timestamp || 0),
                                            fileName: fileName,
                                            createdAt: note.createdAt || new Date().toISOString()
                                        }));

                                        localStorage.setItem(key, JSON.stringify(processedNotes));
                                        importedFiles++;
                                        importedNotes += processedNotes.length;
                                    }
                                });

                                showProgress(90);

                                // Reload current file if it was imported
                                if (currentFileName && importData.data[currentFileName]) {
                                    loadNotesForFile();
                                }

                                showProgress(100);
                                showStatus('success', `Import completed! ${importedFiles} files and ${importedNotes} notes imported.`);
                            }
                        } else if (importData.notes && Array.isArray(importData.notes)) {
                            // Legacy single-file format
                            const fileName = importData.fileName || 'imported_file';
                            const shouldImport = confirm(
                                `Import ${importData.notes.length} notes for "${fileName}"?\n\nThis will replace existing notes for this file.`
                            );

                            if (shouldImport) {
                                showProgress(60);

                                const key = `notes_${fileName}`;
                                const processedNotes = importData.notes.map(note => ({
                                    ...note,
                                    id: note.id || Date.now() + Math.random(),
                                    timeString: note.timeString || formatTime(note.timestamp || 0),
                                    fileName: fileName,
                                    createdAt: note.createdAt || new Date().toISOString()
                                }));

                                localStorage.setItem(key, JSON.stringify(processedNotes));

                                showProgress(90);

                                if (currentFileName === fileName) {
                                    loadNotesForFile();
                                }

                                showProgress(100);
                                showStatus('success', `Import completed! ${processedNotes.length} notes imported for "${fileName}".`);
                            }
                        } else {
                            throw new Error('Invalid JSON format. Expected data with notes structure.');
                        }
                    } else {
                        throw new Error('Unsupported file format. Please use JSON files for import.');
                    }

                    setTimeout(() => {
                        hideProgress();
                        hideStatus();
                    }, 3000);

                } catch (error) {
                    console.error('Import error:', error);
                    showStatus('error', 'Import failed: ' + error.message);
                    hideProgress();
                }

                event.target.value = '';
            };

            reader.onerror = function (error) {
                console.error('FileReader error:', error);
                showStatus('error', 'Error reading file. Please try again.');
                hideProgress();
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        function clearAllData() {
            const allData = getAllStoredData();
            const fileCount = Object.keys(allData).length;
            const totalNotes = Object.values(allData).reduce((sum, file) => sum + file.noteCount, 0);

            if (fileCount === 0) {
                alert('No data found to clear.');
                return;
            }

            const shouldClear = confirm(
                `Are you sure you want to clear ALL data?\n\nThis will permanently delete:\n- ${fileCount} audio files\n- ${totalNotes} total notes\n\nThis action cannot be undone.`
            );

            if (shouldClear) {
                const doubleConfirm = confirm('This is your final warning. All audio notes data will be permanently deleted. Continue?');

                if (doubleConfirm) {
                    showStatus('info', 'Clearing all data...');
                    showProgress(0);

                    setTimeout(() => {
                        try {
                            const keys = Object.keys(localStorage);
                            let clearedCount = 0;

                            keys.forEach((key, index) => {
                                if (key.startsWith('notes_')) {
                                    localStorage.removeItem(key);
                                    clearedCount++;
                                }
                                showProgress((index + 1) / keys.length * 90);
                            });

                            // Clear current session
                            notes = [];
                            renderNotes();

                            showProgress(100);
                            showStatus('success', `All data cleared! ${clearedCount} files removed.`);

                            setTimeout(() => {
                                hideProgress();
                                hideStatus();
                            }, 3000);

                        } catch (error) {
                            console.error('Clear data error:', error);
                            showStatus('error', 'Error clearing data: ' + error.message);
                            hideProgress();
                        }
                    }, 500);
                }
            }
        }

        function showStatus(type, message) {
            const statusDiv = document.getElementById('dataManagementStatus');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        function hideStatus() {
            const statusDiv = document.getElementById('dataManagementStatus');
            statusDiv.style.display = 'none';
        }

        function showProgress(percentage) {
            const progressDiv = document.getElementById('dataManagementProgress');
            const progressFill = progressDiv.querySelector('.progress-fill');
            progressDiv.style.display = 'block';
            progressFill.style.width = `${percentage}%`;
        }

        function hideProgress() {
            const progressDiv = document.getElementById('dataManagementProgress');
            progressDiv.style.display = 'none';
        }

        function toggleManagementPanels() {
            const cloudSection = document.querySelector('.cloud-section');
            const dataSection = document.querySelector('.data-management-section');
            const btn = document.getElementById('togglePanelsBtn');

            const isHidden = cloudSection.classList.contains('hidden');

            if (isHidden) {
                cloudSection.classList.remove('hidden');
                dataSection.classList.remove('hidden');
                btn.innerHTML = '⚙️ Hide Management';
            } else {
                cloudSection.classList.add('hidden');
                dataSection.classList.add('hidden');
                btn.innerHTML = '⚙️ Show Management';
            }
        }

        function toggleTheme() {
            const body = document.body;
            const button = document.querySelector('.theme-toggle');

            if (body.getAttribute('data-theme') === 'dark') {
                body.removeAttribute('data-theme');
                button.textContent = '🌙 Dark Mode';
                try {
                    localStorage.setItem('audioNotes_theme', 'light');
                } catch (e) {
                    console.log('Could not save theme preference');
                }
            } else {
                body.setAttribute('data-theme', 'dark');
                button.textContent = '☀️ Light Mode';
                try {
                    localStorage.setItem('audioNotes_theme', 'dark');
                } catch (e) {
                    console.log('Could not save theme preference');
                }
            }
        }

        function loadTheme() {
            try {
                const savedTheme = localStorage.getItem('audioNotes_theme');
                const button = document.querySelector('.theme-toggle');

                if (savedTheme === 'dark') {
                    document.body.setAttribute('data-theme', 'dark');
                    button.textContent = '☀️ Light Mode';
                } else {
                    button.textContent = '🌙 Dark Mode';
                }
            } catch (e) {
                console.log('Could not load theme preference');
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function (e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            const audioPlayer = document.getElementById('audioPlayer');
            if (!audioPlayer || !audioPlayer.src) {
                return;
            }

            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    if (audioPlayer.paused) {
                        audioPlayer.play().catch(err => console.log('Play failed:', err));
                    } else {
                        audioPlayer.pause();
                    }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 5);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (!isNaN(audioPlayer.duration)) {
                        audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 5);
                    }
                    break;
                case 'n':
                case 'N':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const noteInput = document.getElementById('noteInput');
                        if (noteInput && !noteInput.disabled) {
                            noteInput.focus();
                        }
                    }
                    break;
            }
        });

        // Add Enter + Ctrl shortcut to add note
        document.getElementById('noteInput').addEventListener('keydown', function (e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                e.preventDefault();
                addNote();
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function () {
            if (currentAudio) {
                URL.revokeObjectURL(currentAudio);
            }
        });
    </script>
</body>

</html>
